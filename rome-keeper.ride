{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let VERSION = "RK-1.0.0"

let Scale8 = 100000000

let aggregatorAddress = getString("setup_aggregator").valueOrElse("").addressFromString().valueOrElse(Address(base58'3PGFHzVGT4NTigwCKP1NcwoXkodVZwvBuuU'))
let maxSwapAmount = getInteger("setup_maxSwapAmount").valueOrElse(10000000)

func getAssetString(assetId: ByteVector|Unit) = {
  match assetId {
    case b:ByteVector => b.toBase58String()
    case _ => "WAVES"
  }
}

func getAssetBytes(assetIdStr: String) = {
  if (assetIdStr == "WAVES") then {unit} else {assetIdStr.fromBase58String()}
}

func getBalance(assetIdStr: String) = {
  if (assetIdStr == "WAVES") then {wavesBalance(this).available} else {assetBalance(this, assetIdStr.fromBase58String())}
}


func getTargetReturn(assetFrom: String, assetsRatio: Int) = {
  let ratios = getStringValue("setup_targets_"+assetFrom).split(";") # "80000000,103000000;50000000;105000000;30000000,110000000;10000000,120000000;0,200000000"
  func f(accum: Int, next: String) = {
    let li = next.split(",")
    if (assetsRatio < li[0].parseIntValue()) then {li[1]} else {accum}
  }

  FOLD<10>(ratios, 100000000, f)
}


@Callable(i)
func init() = {
  if (i.caller != this) then {throw("available for self-invoke only")}
  else {
    [
      StringEntry("setup_targets_9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi", "80000000,103000000;50000000;105000000;30000000,110000000;10000000,120000000;0,200000000"),
      IntegerEntry("global_balance_9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi", Scale8),
      StringEntry("setup_targets_AP4Cb5xLYGH6ZigHreCZHoXpQTWDkPsG2BHqfDUx6taJ", "80000000,103000000;50000000;105000000;30000000,110000000;10000000,120000000;0,200000000"),
      IntegerEntry("global_balance_AP4Cb5xLYGH6ZigHreCZHoXpQTWDkPsG2BHqfDUx6taJ", Scale8)
    ]
  }
}


@Callable(i)
func doSwap(asset0Str: String, asset1Str: String, amount: Int, route: String) = {
  let asset0Bal = getInteger("global_balance_"+asset0Str).valueOrErrorMessage("asset not supported " + asset0Str)
  let asset1Bal = getInteger("global_balance_"+asset1Str).valueOrErrorMessage("asset not supported " + asset1Str)
  let currentRatio = fraction(asset0Bal, Scale8, asset1Bal+asset0Bal)
  let targetReturn = getTargetReturn(asset0Str, currentRatio)

  let asset0 = getAssetBytes(asset0Str)
  let asset1 = getAssetBytes(asset1Str)

  strict asset1BalBefore = getBalance(asset1Str)
  strict swapTx = invoke(aggregatorAddress, "swap", [route, amount], [AttachedPayment(asset0, amount)])
  strict asset1BalChange = getBalance(asset1Str) - asset1BalBefore

  if (maxSwapAmount < amount) then {throw("amount to swap exceeds a limit")}
  else if (fraction(asset1BalChange, Scale8, amount) < targetReturn) then { throw("swap premium is not enough to perform arbitrage") }
  else {

    [
      IntegerEntry("global_balance_"+asset0Str, asset0Bal + amount),
      IntegerEntry("global_balance_"+asset1Str, asset1Bal + asset1BalChange)
    ]

  }
}


@Callable(i)
func mintLP() = {
  [
  ]
}


@Callable(i)
func redeemLP() = {
  [
  ]
}


@Callable(i)
func updateString(key: String, val: String) = {
  if (this != i.caller) then {throw("admin only")}
  else {
    [
      StringEntry(key, val)
    ]
  }
}


@Callable(i)
func updateInt(key: String, val: Int) = {
  if (this != i.caller) then {throw("admin only")}
  else {
    [
      IntegerEntry(key, val)
    ]
  }
}
        
